package claims

import (
	"time"

	"get.porter.sh/porter/pkg/cnab"
	"get.porter.sh/porter/pkg/secrets"
	"get.porter.sh/porter/pkg/storage"
	"github.com/cnabio/cnab-go/bundle"
	"github.com/cnabio/cnab-go/driver"
	"github.com/cnabio/cnab-go/schema"
)

var _ storage.Document = Result{}

type Result struct {
	// SchemaVersion of the document.
	SchemaVersion schema.Version `json:"schemaVersion" yaml:"schemaVersion" toml:"schemaVersion"`

	// ID of the result.
	ID string `json:"_id" yaml:"_id" toml:"_id"`

	// Created timestamp of the result.
	Created time.Time `json:"created" yaml:"created" toml:"created"`

	// Namespace of the installation.
	Namespace string `json:"namespace" yaml:"namespace" toml:"namespace"`

	// Installation name that owns this result.
	Installation string `json:"installation" yaml:"installation" toml:"installation"`

	// RunID of the run that generated this result.
	RunID string `json:"runId" yaml:"runId" toml:"runId"`

	// Message communicates the outcome of the operation.
	Message string `json:"message,omitempty" yaml:"message,omitempty" toml:"message,omitempty"`

	// Status of the operation, for example StatusSucceeded.
	Status string `json:"status" yaml:"status" toml:"status"`

	// OutputMetadata generated by the operation, mapping from the output names to
	// metadata about the output.
	OutputMetadata OutputMetadata `json:"outputs" yaml:"outputs" toml:"outputs"`

	// Custom extension data applicable to a given runtime.
	Custom interface{} `json:"custom,omitempty" yaml:"custom,omitempty" toml:"custom,omitempty"`
}

func (r Result) DefaultDocumentFilter() interface{} {
	return map[string]interface{}{"_id": r.ID}
}

func NewResult() Result {
	return Result{
		SchemaVersion: SchemaVersion,
		ID:            cnab.NewULID(),
		Created:       time.Now(),
	}
}

func (r Result) NewOutput(name string, data []byte) Output {
	return Output{
		SchemaVersion: SchemaVersion,
		Name:          name,
		Namespace:     r.Namespace,
		Installation:  r.Installation,
		RunID:         r.RunID,
		ResultID:      r.ID,
		Value:         data,
	}
}

func (r Result) FilterSensitiveOutputs(result driver.OperationResult, bun bundle.Bundle, store secrets.Store) []Output {
	o := make([]Output, 0, len(result.Outputs))
	for name, value := range result.Outputs {
		sensitive, err := bun.IsOutputSensitive(name)
		ot := r.NewOutput(name, []byte(value))
		if err != nil || !sensitive {
			o = append(o, ot)
			continue
		}

		ot = ot.FormatSensitive()
		o = append(o, ot)
		store.Create(secrets.SourceSecret, string(ot.Value), string(value))
	}

	return o
}
